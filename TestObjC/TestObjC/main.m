//
//  main.m
//  TestObjC
//
//  Created by Genek on 5/3/17.
//  Copyright © 2017 Genek. All rights reserved.
//

#import <Foundation/Foundation.h>

#import "NSString+IDPRandomString.h"

int main(int argc, const char * argv[]) {
    @autoreleasepool {
        NSLog(@"%@", [NSString randomStringWithAlphabet:[NSString alphabetWithType:IDPUppercaseLettersAlphabet]]);
    }
    
    return 0;
}

// C

//Рассказать:
//- компиляция (препроцессор, компилятор, ассемблер, линкер)
//- инклуды
//- макросы
//- комментарии
//- функции
//- тестирование
//- строки
//- переменные
//- циклы (for, while, do..while)
//- if, else, else if, switch
//- форматированный вывод строк
//- типы
//- sizeof
//- область видимости (локальная, глобальная)
//- числа с плавающей точкой
//- стек и куча
//- массивы данных на стеке

//Задание:
//1. Вывести размер типов через sizeof.
//2. Создать метод, который бы имел, как параметр, целое число.
//Пользовательские истории:
//- если на вход приходит число, кратное 3, то в консоль должно быть выведено: "мама";
//- если на вход приходит число, кратное 5, то в консоль должно быть выведено: "папа";
//- если на вход приходит число, кратное 15, то в консоль должно быть выведено: "мамапапа";
//- если на вход приходит число, не удовлетворяющие критериям выше, то в консоль ничего выводить не надо, либо вывести “”, либо “\n”;
//Требования:
//- необходимо в цикле пройти 1000 итераций, вывести номер итерации и передать номер итерации в метод.

//Рассказать:
//- =+-*/%
//- бинарное представление чисел
//- ^|&
//- ||&&
//- указатели
//- malloc и free
//- массивы данных на куче

//Создать макрос, который бы генерировал метод для вывода в консоль значения любого примитивного типа. У макроса должно быть 2 параметра: тип, спецификатор вывода. При препроцессинге макрос должен создавать метод output_type, где вместо type должен быть подставлен тип, который мы выводим данным сгенерированным методом. Создать второй макрос, который бы занимался вызовом сгенерированного первым макросом метода, на вход должен получать тип метода.
//Требования:
//- создать тестовые методы для проверки того, как работает генерация на всех примитивных типах.

//Рассказать:
//- typedef
//- структуры
//- alignment
//- bitfields
//- union
//- offsetof

//Задачи:
//1. Создать структуру, данных, хранящую в себе расположенные в случайном порядке 6 bool, 1 float, 1 int, 1 long long, 3 short, 1 double, 1 указатель на строку.
//Требования:
//- создать тестовый метод, который бы с помощью offsetof выводил расположение каждого из элементов;
//- создать тестовый метод, который бы выводил размер всей структуры;
//- перекомпоновать структуру так, чтобы она занимала наименьшее количество места;
//- поместить bool значения в битовое поле и создать union;
//2. Создать метод для вывода битов числа в консоль.

//malloc, realloc, free, typecasting, pointer arithmetic.

//Задание:
//Создать структуру типа массив, которая бы реализовывала следующие требования:
//1. Структура должна владеть указателем на массив элементов.
//2. Должен существовать метод создания структуры на куче.
//3. Должен существовать метод деаллокации структуры на куче.
//4. Массив должен создаваться с произвольным начальным количеством места под элементы.
//5. Элементом может быть сущность произвольного размера в байтах.
//6. Массив должен поддерживать расширение, сужение занимаемого в памяти места в зависимости от количества элементов.

//NSOBject, NSArray, NSMutableArray, NSDictionary, NSMutableDictionary, NSString, NSMutabeString, NSSet, NSMutableSet, NSData, NSMutableData
//Литералы

//Objective C

//Задание 1.
//Условие:
//Есть существо, у существа есть typedef пола, есть строка имени, есть масса, есть возраст, есть массив детей. Существо умеет воевать и рожать детей. При родах существо не добавляет к себе ребенка автоматом. Существо умеет добавит к себе детей и удалить. Существо умеет говорить "Привет!", причем, когда существо говорит привет, то сначала говорит оно, а потом все его дети (значит и дети детей, и т.д.).
//Задание:
//1. Написать класс существа;
//2. Создать несколько существ и положить их в массив, каждому из существ добавить детей;
//3. В цикле пройти по массиву существ и проверить их пол. Если мужик, то надо отправить существо воевать, если баба, то рожать детей;
//4. У существа наружу должен быть немутабельный массив детей через динамическое проперти с копи+авторелиз, а внутри - еще и мутабельное свойство.

//Задание 2.
//Условие:
//Дано существо из задания 1.
//Задание:
//1. Убрать переменную пол из существа, а также умение воевать и рожать детей;
//2. Вместо нее создать наследников существа: мужское и женское существо;
//3. Мужское существо умеет воевать, женское - рожать детей;
//4. Создать метод performGenderSpecificOperation у родительского существа, который ничего не делает, мужское существо по вызову этого метода идет воевать, женское рожает детей;
//5. Создать массив существ, в котором бы лежали только мужчины и женщины, пройтись по нему через for (Creature *creature in creatures) и вызвать метод performGenderSpecificOperation, которой, в зависимости от пола существа приведет либо к войне, либо к родам -> Подчеркнуть, что это - полиморфизм, значит, охуенно.
//6. Заменить alloc init autorelease на NSOBject категорию с методом object

//Задание 3.
//Условие:
//1. Есть автомойка и есть админ здание;
//2. И то, и другое является зданием;
//3. Каждое из них имеет отдельные помещения;
//4. Каждое помещение рассчитано на определенное количество людей;
//5. У автомойки помещения могут еще вмещать и машины;
//6. Работники автомойки деляцца на мойщиков, бухгалтеров и директоров;
//7. Все они - люди, у которых разная зарплата, опыт работы и обязанности;
//8. Бухгалтера считают деньги;
//9. Директора получают прибыль;
//10. Мойщики моют машины;
//11. Финансовые потоки идут по пути обработки машины - мойщики - бухгалтера - директора;
//12. Есть машины, у которых есть деньги, до мойки они грязные, а после мойки чистые.
//13. Есть одно здание мойки с одной комнатой и одним мойщиком
//14. Есть одно здание администрации с одной комнатой, в которой сидит бухгалтер и директор.
//Задание:
//Придумать и реализовать иерархию классов автомойки, учитывая, что используецца следуюший процесс взаимодействий:
//1. Мойщику мойки отдают машину
//2. Мойщик моет машину
//3. Мойщик забирает деньги у машины
//4. Мойщик отдает деньги бухгалтеру
//5. Бухгалтер считает деньги
//6. Бухгалтер отдает деньги директору
//7. Директор получает прибыль

//Задание 4
//Написать расширения для строки, которая бы генерировалась случайным образом.
//ТРебования:
//1. должна быть расширяемой
//2. должна быть удобной
//3. должна предоставлять возможность работать с разными наборами символов

//Задание 5.
//Написать класс, реализующий собственный кластерный массив над числами:
//Требования:
//1. не должен быть наследником nsarray
//2. может быть:
//- динамически генерирующим элементы в каком-то промежутке, где первый эелемент - начало промежутка, а последний - конец;
//- надстройкой над связным списком (хранилищем данных выступает связный список);
//- массивом из нескольких массивов чисел (т.е. генерирующих и связных списков);
//3. должен быть кластерным классом
//4. должен уметь NSFastEnumeration
//5. написать тесты

//Задание 6.
//Условие:
//Есть иерархия сотрудников из задания 3 cо следующими ограничениями:
//1. 1 мойщик моет одну машину за раз
//2. На всем предприятии есть рандомное количество мойщиков, один бухгалтер и один директор
//3. Выкинуть сами здания
//Задание:
//Реализовать иерархию классов с наблюдением за состоянием со следующим потоком денег: машина заезжает на мойку, после мытья машины мойщик берет деньги у машины, сообщает бухгалтеру, что получил деньги, бухгалтер забирает деньги у мойщика, бухгалтер считает и после этого сообщает директору, что посчитал деньги, и директор их забирает.
