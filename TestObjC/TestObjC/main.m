//
//  main.m
//  TestObjC
//
//  Created by Genek on 5/3/17.
//  Copyright © 2017 Genek. All rights reserved.
//

#import <Foundation/Foundation.h>

#import "IDPCreatureTest.h"
#import "IDPCreature2Test.h"
#import "IDPEnterpriseTest.h"

int main(int argc, const char * argv[]) {
    @autoreleasepool {
//        [IDPCreatureTest performTest];
//        [IDPCreature2Test performTest];
        testCarwashWithCarsCount(10);
    }
    
    return 0;
}

// C

//Рассказать:
//- компиляция (препроцессор, компилятор, ассемблер, линкер)
//- инклуды
//- макросы
//- комментарии
//- функции
//- тестирование
//- строки
//- переменные
//- циклы (for, while, do..while)
//- if, else, else if, switch
//- форматированный вывод строк
//- типы
//- sizeof
//- область видимости (локальная, глобальная)
//- числа с плавающей точкой
//- стек и куча
//- массивы данных на стеке

//Задание:
//1. Вывести размер типов через sizeof.
//2. Создать метод, который бы имел, как параметр, целое число.
//Пользовательские истории:
//- если на вход приходит число, кратное 3, то в консоль должно быть выведено: "мама";
//- если на вход приходит число, кратное 5, то в консоль должно быть выведено: "папа";
//- если на вход приходит число, кратное 15, то в консоль должно быть выведено: "мамапапа";
//- если на вход приходит число, не удовлетворяющие критериям выше, то в консоль ничего выводить не надо, либо вывести “”, либо “\n”;
//Требования:
//- необходимо в цикле пройти 1000 итераций, вывести номер итерации и передать номер итерации в метод.

//Рассказать:
//- =+-*/%
//- бинарное представление чисел
//- ^|&
//- ||&&
//- указатели
//- malloc и free
//- массивы данных на куче

//Создать макрос, который бы генерировал метод для вывода в консоль значения любого примитивного типа. У макроса должно быть 2 параметра: тип, спецификатор вывода. При препроцессинге макрос должен создавать метод output_type, где вместо type должен быть подставлен тип, который мы выводим данным сгенерированным методом. Создать второй макрос, который бы занимался вызовом сгенерированного первым макросом метода, на вход должен получать тип метода.
//Требования:
//- создать тестовые методы для проверки того, как работает генерация на всех примитивных типах.

//Рассказать:
//- typedef
//- структуры
//- alignment
//- bitfields
//- union
//- offsetof

//Задачи:
//1. Создать структуру, данных, хранящую в себе расположенные в случайном порядке 6 bool, 1 float, 1 int, 1 long long, 3 short, 1 double, 1 указатель на строку.
//Требования:
//- создать тестовый метод, который бы с помощью offsetof выводил расположение каждого из элементов;
//- создать тестовый метод, который бы выводил размер всей структуры;
//- перекомпоновать структуру так, чтобы она занимала наименьшее количество места;
//- поместить bool значения в битовое поле и создать union;
//2. Создать метод для вывода битов числа в консоль.

//malloc, realloc, free, typecasting, pointer arithmetic.

//Задание:
//Создать структуру типа массив, которая бы реализовывала следующие требования:
//1. Структура должна владеть указателем на массив элементов.
//2. Должен существовать метод создания структуры на куче.
//3. Должен существовать метод деаллокации структуры на куче.
//4. Массив должен создаваться с произвольным начальным количеством места под элементы.
//5. Элементом может быть сущность произвольного размера в байтах.
//6. Массив должен поддерживать расширение, сужение занимаемого в памяти места в зависимости от количества элементов.

//NSOBject, NSArray, NSMutableArray, NSDictionary, NSMutableDictionary, NSString, NSMutabeString, NSSet, NSMutableSet, NSData, NSMutableData
//Литералы

//Objective C

//Задание 1.
//Условие:
//Есть существо, у существа есть typedef пола, есть строка имени, есть масса, есть возраст, есть массив детей. Существо умеет воевать и рожать детей. При родах существо не добавляет к себе ребенка автоматом. Существо умеет добавит к себе детей и удалить. Существо умеет говорить "Привет!", причем, когда существо говорит привет, то сначала говорит оно, а потом все его дети (значит и дети детей, и т.д.).
//Задание:
//1. Написать класс существа;
//2. Создать несколько существ и положить их в массив, каждому из существ добавить детей;
//3. В цикле пройти по массиву существ и проверить их пол. Если мужик, то надо отправить существо воевать, если баба, то рожать детей;
//4. У существа наружу должен быть немутабельный массив детей через динамическое проперти с копи+авторелиз, а внутри - еще и мутабельное свойство.

//Задание 2.
//Условие:
//Дано существо из задания 1.
//Задание:
//1. Убрать переменную пол из существа, а также умение воевать и рожать детей;
//2. Вместо нее создать наследников существа: мужское и женское существо;
//3. Мужское существо умеет воевать, женское - рожать детей;
//4. Создать метод performGenderSpecificOperation у родительского существа, который ничего не делает, мужское существо по вызову этого метода идет воевать, женское рожает детей;
//5. Создать массив существ, в котором бы лежали только мужчины и женщины, пройтись по нему через for (Creature *creature in creatures) и вызвать метод performGenderSpecificOperation, которой, в зависимости от пола существа приведет либо к войне, либо к родам -> Подчеркнуть, что это - полиморфизм, значит, охуенно.
//6. Заменить alloc init autorelease на NSOBject категорию с методом object

//Задание 3.
//Условие:
//1. Есть автомойка и есть админ здание;
//2. И то, и другое является зданием;
//3. Каждое из них имеет отдельные помещения;
//4. Каждое помещение рассчитано на определенное количество людей;
//5. У автомойки помещения могут еще вмещать и машины;
//6. Работники автомойки деляцца на мойщиков, бухгалтеров и директоров;
//7. Все они - люди, у которых разная зарплата, опыт работы и обязанности;
//8. Бухгалтера считают деньги;
//9. Директора получают прибыль;
//10. Мойщики моют машины;
//11. Финансовые потоки идут по пути обработки машины - мойщики - бухгалтера - директора;
//12. Есть машины, у которых есть деньги, до мойки они грязные, а после мойки чистые.
//13. Есть одно здание мойки с одной комнатой и одним мойщиком
//14. Есть одно здание администрации с одной комнатой, в которой сидит бухгалтер и директор.
//Задание:
//Придумать и реализовать иерархию классов автомойки, учитывая, что используецца следуюший процесс взаимодействий:
//1. Мойщику мойки отдают машину
//2. Мойщик моет машину
//3. Мойщик забирает деньги у машины
//4. Мойщик отдает деньги бухгалтеру
//5. Бухгалтер считает деньги
//6. Бухгалтер отдает деньги директору
//7. Директор получает прибыль

//Задание 4
//Написать расширения для строки, которая бы генерировалась случайным образом.
//ТРебования:
//1. должна быть расширяемой
//2. должна быть удобной
//3. должна предоставлять возможность работать с разными наборами символов

//Задание 5.
//Написать класс, реализующий собственный кластерный массив над числами:
//Требования:
//1. не должен быть наследником nsarray
//2. может быть:
//- динамически генерирующим элементы в каком-то промежутке, где первый эелемент - начало промежутка, а последний - конец;
//- надстройкой над связным списком (хранилищем данных выступает связный список);
//- массивом из нескольких массивов чисел (т.е. генерирующих и связных списков);
//3. должен быть кластерным классом
//4. должен уметь NSFastEnumeration
//5. написать тесты

//Задание 6.
//Условие:
//Есть иерархия сотрудников из задания 3 cо следующими ограничениями:
//1. 1 мойщик моет одну машину за раз
//2. На всем предприятии есть рандомное количество мойщиков, один бухгалтер и один директор
//3. Выкинуть сами здания
//Задание:
//Реализовать иерархию классов с наблюдением за состоянием со следующим потоком денег: машина заезжает на мойку, после мытья машины мойщик берет деньги у машины, сообщает бухгалтеру, что получил деньги, бухгалтер забирает деньги у мойщика, бухгалтер считает и после этого сообщает директору, что посчитал деньги, и директор их забирает.

//Задание 7.
//Условие:
//Есть иерархия из задания 6.
//Задание:
//1. Бухгалтер и директор на предприятии один и просто синхронизированы на выполнение одной операции за раз (бухгалтер считает деньги одного рабочего, остальные ждут)
//2. Переделать код так, чтобы выполнение операций обработки выполнялось бухгалтерами и мойщиками через performSelectorInBackground в бекграундном потоке с последующей нотификацией наблюдателей в главной потоке через performSelectorOnMainThread;
//3. Каждая из асинхронных операций должна выполняцца разное время (через вызов sleep(n) внутри блока);
//4. Надо учесть то, что у нас есть проблема с тем, что сразу из нескольких потоков может модифицировацца массив наблюдателей, что приведет к падению, дял избежания создать потокобезопасный наблюдаемый объект с синхронизацией, отвечающий следующим требованиям:
//а. может происходить только одна операция с внутренним мутабельным массивом за раз, будь то копирование, добавление или чтение объекта;
//б. должен быть абстрактным базовым классом, который мы уже в детях расширяем поведением;
//в. поскольку он ничего не знает о том, какие именно методы будут использовацца для нотификаций в детях, необходимо придумать метод, который бы давал универсальную возможность для нотификации с использованием разных методов (т.е. надо передавать селектор, используемый для нотификаций);
//г. надо придумать еще один метод, как обертку дял метода из в., который бы перед нотификациями синхронным образом переходил в главный поток и оттуда производил нотификации;
//5. Создать контролирующий класс, который бы занимался управлением автомойкой, т.е. следил (через наблюдение) за тем, кто из рабочих освободился и передавал ему следующую машину для мытья. Контроллер работает следующим образом:
//а. получил из разных потоков количество машин большее, чем количество мойщиков;
//б. передал машины мойщикам, а остальные машины стоят в очереди на мытье;
//в. наблюдает за всеми мойщиками;
//г. когда мойщик закончил мытье, то необходимо ему передать следующую машину на мытье.
//д. должен быть потокобезопасным с точки зрения управления мойщиками и очередью машин;
//6. Сгенерировать протокол следующих состояний мойщика и бухгалтера:
//а. готов к работе
//б. работает
//в. нуждается в обработке
//7. Поток денег идет следующим образом:
//- мойщик получил машину;
//- мойщик помыл машину;
//- мойщик забрал деньги у авто;
//- мойщик сообщил наблюдателям, что завершил работу;
//- бухгалтер наблюдает за мойщиком;
//- когда бухгалтер узнал, что мойщик помыл машину, то забрал у мойщика деньги;
//- мойщик сообщил наблюдателям, что готов к новой работе;
//- бухгалтер посчитал деньги и сообщил директору, что завершил работу;
//- директор сделал профит.
//8. вся логика переходов между потоками реализована в родительском классе работник;
//- необходимо создать такую логику переходов, чтобы:
//а. наличествовали методы, доступные для перегрузки, которые бы всегда выполнялись в бекграунде и главном потоке;
//б. эти методы должны быть обернуты в приватные методы, которые и обсепечивают логику переходов между потоками;
//в. по окончании обработки и переходе в главный поток сам работник должен сообщать наблюдателям, что он закончил работу;
//- в детях должна быть реализована только сама логика обработки данных на главном и бекграундном потоке, но не должно происходить перехода из потока в поток, т.к. все это должно быть реализовано в родительском классе
